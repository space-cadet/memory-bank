# T20a: Adaptive LLM-Based Format Parser System

*Created: 2025-11-12 17:25:21 IST*
*Last Updated: 2025-11-12 17:25:21 IST*

**Description**: Design and implement adaptive parser system using LLM format analysis to handle memory bank file format variations across different projects, normalizing to universal database schema.

**Status**: ðŸ”„ In Progress (Design Phase)

**Priority**: HIGH

**Started**: 2025-11-12

**Last Active**: 2025-11-12 17:25:21 IST

**Dependencies**: T20

## Completion Criteria

- âœ… Format variation analysis across projects completed
- â¬œ LLM format analysis prompt design
- â¬œ Format profile extraction logic
- â¬œ Parser selection mechanism
- â¬œ Universal schema mapping implementation
- â¬œ Multi-project database initialization
- â¬œ End-to-end testing across 4+ projects

## Progress

### Phase 1: Analysis & Design (In Progress)
- âœ… Examined edit_history.md formats from 4 projects (memory-bank, spin-network-app, qc-diffusion-code, arxivite)
- âœ… Documented 8 critical format variations (metadata syntax, entry headers, task IDs, file paths, etc.)
- âœ… Identified format analysis approach as superior to universal regex parser
- âœ… Designed three-phase system architecture (Analysis â†’ Parser Generation â†’ Normalization)
- ðŸ”„ Documenting system architecture and design decisions

### Phase 2: LLM Format Analysis (Planned)
- â¬œ Design LLM prompt for format specification extraction
- â¬œ Implement format profile generation
- â¬œ Test LLM output quality and consistency

### Phase 3: Parser Implementation (Planned)
- â¬œ Implement format-agnostic parser for each detected pattern
- â¬œ Build parser selection logic
- â¬œ Create intermediate data structures

### Phase 4: Schema Normalization (Planned)
- â¬œ Map intermediate format to universal schema
- â¬œ Implement normalization functions
- â¬œ Test data integrity across projects

### Phase 5: Integration (Planned)
- â¬œ Integrate with T20 database initialization
- â¬œ Multi-project batch processing
- â¬œ Error handling and recovery

## Related Files

- `implementation-details/adaptive-parser-plan.md` - System architecture and detailed design
- `implementation-details/parser-format-analysis/format-variations-discovered.md` - Format analysis findings
- `implementation-details/database-parser-plan.md` - Original T20 database plan (to be updated)
- `tasks/T20.md` - Parent task (database parser implementation)

## Context

T20 discovered that different projects use inconsistent memory bank file formats. Rather than building a complex universal regex parser, T20a implements an adaptive system that uses LLM analysis to detect the actual format structure and generate appropriate parsers. This maintains a single unified database schema while handling format variations gracefully.

### Key Design Decisions

1. **Format-agnostic schema** - One universal schema for all projects
2. **LLM-driven detection** - Not tied to specific projects, analyzes actual structure
3. **Separate project databases** - Each project keeps its own memory_bank.db
4. **Three-phase pipeline** - Analysis â†’ Parser Selection â†’ Normalization
5. **One-time initialization** - Format detection runs once per project during setup

## Implementation Notes

**System Flow:**

```
Input: Memory bank files (edit_history.md, tasks.md, etc.)
  â†“
Phase 1: LLM analyzes first 30-50 lines
  â†’ Generates format profile (not project-specific)
  â†“
Phase 2: Parser selected based on format profile
  â†’ Extracts logical data (timestamp, taskID, files, etc.)
  â†“
Phase 3: Normalized data inserted to universal schema
  â†’ Stored in project's memory_bank.db
```

**Universal Schema Tables:**
- edit_entries (id, date, time, task_id, description, created_at)
- file_modifications (id, entry_id, action, file_path, change_description, file_type)
- tasks (id, task_id, title, status, priority, created_date, dependencies)
- task_files (id, task_id, file_path, file_type)

## Next Steps

1. Design LLM prompt for format specification extraction
2. Implement format profile generation and persistence
3. Build parser selection and configuration mechanism
4. Create universal schema mapping layer
5. Test across all projects
